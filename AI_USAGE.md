# AI Usage

Claude Code with model Sonnet 4.6 was used with basically two prompts

## Prompt 1
```
I want to make a Nexcloud plugin app. The goal is to allow the user who install the plugin to set a URL that public
shares will use. For example: imagine that the user set up nexcloud at files.internal.domain.com. This domain points
to an internal network, so public shares using that domain will not work for users outside this network. The
Nexcloud instance admin could then install my "custom_public_share" plugin and configure the public share domain to
be files-share.domain.com. This domain would then have an internet facing reverse proxy that's also in the internal
network and then can forward the requests to files.internal.domain.com. The proxy configuration outside the scope of
the plugin. We will only build the means to configure the custom URL and the logic to replace the default Nexcloud
domain when building a public share link.
```

### Resulting plan
Plan: Nextcloud custom_public_share App

Context

The user runs Nextcloud on an internal domain (e.g., files.internal.domain.com) that is not reachable from the internet. Public share
links generated by Nextcloud use this internal domain, making them useless for external recipients. This app lets an admin configure a
custom domain (e.g., files-share.domain.com) that will be substituted into all public share links shown in the UI. The external domain
would point to an internet-facing reverse proxy (configured separately, outside scope of this app).

Key Technical Insight

Nextcloud's Vue frontend ignores the url field from the OCS Share API. The share link displayed to users is built entirely client-side
in SharingEntryLink.vue using window.location as the base. This means only a frontend (JS) approach can change what users see and copy.
Server-side URL rewriting alone would have no effect on the UI.

Approach: Frontend Clipboard & DOM Interception

1. Admin settings page (under "Sharing" section) to store a custom domain via IConfig::setAppValue()
2. Event listener on LoadAdditionalScriptsEvent injects the custom domain into JS via IInitialState and loads the rewrite script
3. JavaScript rewrite script intercepts share URLs using three strategies:
  - navigator.clipboard.writeText override (catches copy-to-clipboard)
  - window.prompt override (clipboard API fallback)
  - MutationObserver (rewrites visible URLs in DOM inputs/links)

Files to Create
```
 custom_public_share/
 ├── appinfo/
 │   ├── info.xml                    # App metadata, NC 30-33, namespace CustomPublicShare
 │   └── routes.php                  # POST/GET /settings routes
 ├── lib/
 │   ├── AppInfo/
 │   │   └── Application.php         # IBootstrap, registers LoadAdditionalScriptsEvent listener
 │   ├── Settings/
 │   │   └── Admin.php               # ISettings under "sharing" section
 │   ├── Controller/
 │   │   └── SettingsController.php  # Save/get custom_domain with URL validation
 │   └── Listener/
 │       └── LoadAdditionalScriptsListener.php  # Provides initial state + loads JS
 ├── templates/
 │   └── admin.php                   # Settings form template
 ├── src/
 │   ├── admin.js                    # Settings save via AJAX (@nextcloud/axios)
 │   └── public-share-rewrite.js     # Core: clipboard/DOM interception
 ├── css/
 │   └── admin.css                   # Minimal admin styles
 ├── package.json                    # @nextcloud/router, initial-state, axios, dialogs
 └── webpack.config.js               # Two entry points: admin + public-share-rewrite
```
Implementation Steps

1. Create project skeleton (appinfo/info.xml, appinfo/routes.php, lib/AppInfo/Application.php)
2. Implement admin settings (Admin.php, SettingsController.php, templates/admin.php, css/admin.css)
3. Implement event listener (LoadAdditionalScriptsListener.php)
4. Set up build tooling (package.json, webpack.config.js)
5. Implement src/admin.js (save settings AJAX)
6. Implement src/public-share-rewrite.js (core URL rewriting logic)
7. Run npm install && npm run build

URL Rewrite Logic (public-share-rewrite.js)

- Uses loadState('custom_public_share', 'custom_domain') to get the configured domain
- Uses getBaseUrl() from @nextcloud/router to know the current Nextcloud base URL
- For any string containing the current base URL + /s/TOKEN pattern, replaces the base with the custom domain
- Normalizes /index.php/s/TOKEN → /s/TOKEN in output

Verification

1. Install the app: symlink or copy to Nextcloud's apps/ directory, enable via occ app:enable custom_public_share
2. Go to Admin → Sharing settings, find "Custom Public Share Domain" section
3. Enter a custom domain (e.g., https://share.example.com), click Save
4. Go to Files, create a public share link, click "Copy link"
5. Paste — the URL should use https://share.example.com/s/TOKEN instead of the default domain
6. Clear the custom domain field and save — share links should revert to default behavior
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

### Resulting code

* commit `37670313f66d3dc3a315e38b9919255db3b99446`

## Prompt 2

```
The plugin works. Now add the share URL rewrite when the users chooses to hare the file via email on the
"External shares" option, the one that goes right above the "Create public link" option. The custom_domain domain
should be used when building the email HTML.
```

### Result

* commit `6009ab8cae64816e7006aa447438b87c1d3c20c1`
* commit `5de35f5344ca34d60dff16beb0976cef3d748798`